@namespace FabOS.WebServer.Components.Shared
@rendermode InteractiveServer
@using FabOS.WebServer.Models.Entities
@using FabOS.WebServer.Data.Contexts
@using FabOS.WebServer.Services.Implementations
@using FabOS.WebServer.Services.Implementations.CloudStorage
@using FabOS.WebServer.Services.Interfaces
@using Microsoft.EntityFrameworkCore
@using System.Text.Json
@using Microsoft.JSInterop
@using Microsoft.Extensions.DependencyInjection
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject IJSRuntime JS
@inject ILogger<NutrientPdfViewer> Logger
@inject IPdfCalibrationService CalibrationService
@inject SharePointStorageProvider CloudStorage
@inject IServiceScopeFactory ScopeFactory
@inject NavigationManager NavigationManager
@inject IPdfLockService LockService
@inject FabOS.WebServer.Hubs.IMeasurementHubService MeasurementHubService
@inject IHttpContextAccessor HttpContextAccessor
@inject ITenantService TenantService
@implements IAsyncDisposable

<div class="nutrient-pdf-viewer">
    @if (isLoading)
    {
        <div class="loading-container">
            <div class="spinner-border"></div>
            <p>Loading PDF viewer...</p>
        </div>
    }
    else if (drawing == null)
    {
        <div class="error-container">
            <i class="fas fa-exclamation-triangle"></i>
            <h3>Drawing not found</h3>
            @if (OnClose.HasDelegate)
            {
                <button class="btn btn-primary" @onclick="() => OnClose.InvokeAsync()">
                    <i class="fas fa-times"></i>
                    Close
                </button>
            }
        </div>
    }
    else if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-container">
            <i class="fas fa-exclamation-triangle"></i>
            <h3>Error Loading PDF</h3>
            <p>@errorMessage</p>
            @if (OnClose.HasDelegate)
            {
                <button class="btn btn-primary" @onclick="() => OnClose.InvokeAsync()">
                    <i class="fas fa-times"></i>
                    Close
                </button>
            }
        </div>
    }
    else
    {
        <!-- Fullscreen Container Wrapper -->
        <div id="@fullscreenContainerId" class="fullscreen-wrapper">
            @if (PackageDrawingId > 0)
            {
                <!-- Top Toolbar (Only for takeoff viewer, not upload preview) -->
                <div class="nutrient-toolbar">
                    <div class="toolbar-section">
                        <button class="tool-btn" @onclick="ToggleSidebar" title="Toggle Catalogue">
                            <i class="fas fa-boxes"></i>
                            Catalogue
                        </button>
                        <h3>@drawing.DrawingNumber - @drawing.DrawingTitle</h3>
                    </div>

                    <div class="toolbar-section tools">
                        <div class="tool-group">
                            <button class="tool-btn" @onclick="ToggleMeasurementPanel" title="Toggle Measurements">
                                <i class="fas fa-calculator"></i>
                                Measurements
                            </button>
                            <button class="tool-btn" @onclick="OpenFullMeasurementsPage" title="Open Measurements in New Window">
                                <i class="fas fa-external-link-alt"></i>
                                Full View
                            </button>
                        </div>

                        <div class="tool-group">
                            @if (!isFullscreen)
                            {
                                <button class="btn btn-primary" @onclick="ToggleFullscreen" title="Enter Fullscreen">
                                    <i class="fas fa-expand"></i>
                                    Fullscreen
                                </button>
                            }
                            else
                            {
                                <button class="btn btn-warning" @onclick="ToggleFullscreen" title="Exit Fullscreen">
                                    <i class="fas fa-compress"></i>
                                    Exit Fullscreen
                                </button>
                            }

                            @if (OnClose.HasDelegate)
                            {
                                <button type="button" class="btn btn-secondary" @onclick="HandleCloseAsync" @onclick:stopPropagation="true" disabled="@isSaving">
                                    @if (isSaving)
                                    {
                                        <i class="fas fa-spinner fa-spin"></i>
                                        <text>Saving...</text>
                                    }
                                    else
                                    {
                                        <i class="fas fa-save"></i>
                                        <text>Save & Close</text>
                                    }
                                </button>
                            }
                        </div>
                    </div>
                </div>

                <!-- View-Only Mode Banner (Only for takeoff viewer) -->
                <ViewOnlyBanner IsEditMode="@isEditMode"
                               EditorName="@(activeLock?.UserName ?? "Another user")"
                               OnRefreshClicked="@TryAcquireEditMode" />
            }

            <!-- Main Content Area -->
            <div class="viewer-main-content @(PackageDrawingId == 0 ? "upload-preview-mode" : "")">
                @if (PackageDrawingId > 0)
                {
                    <!-- Catalogue Sidebar (Left) - Only for takeoff viewer -->
                    <TakeoffCatalogueSidebar IsVisible="@sidebarVisible"
                                            IsVisibleChanged="@((bool v) => sidebarVisible = v)"
                                            SelectedItem="@selectedCatalogueItem"
                                            SelectedItemChanged="@OnCatalogueItemSelected" />
                }

                <!-- Nutrient PDF Container (Center) -->
                <div class="nutrient-container-wrapper">
                    <div id="@containerId" class="nutrient-pdf-container"></div>
                </div>

                @if (PackageDrawingId > 0)
                {
                    <!-- Measurement Panel (Right) - Only for takeoff viewer -->
                    <TakeoffMeasurementPanel PackageDrawingId="@PackageDrawingId"
                                            PdfContainerId="@containerId"
                                            IsVisible="@measurementPanelVisible"
                                            IsVisibleChanged="@OnMeasurementPanelVisibilityChanged"
                                            OnMeasurementSaved="@OnMeasurementSaved"
                                            @ref="measurementPanel" />
                }
            </div>
        </div><!-- End Fullscreen Wrapper -->
    }
</div>

@code {
    [Parameter] public int PackageDrawingId { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }

    // OCR support parameters (for FileUploadModal scenario)
    [Parameter] public string? PdfDataUrl { get; set; }
    [Parameter] public OcrAnalysisResult? OcrResult { get; set; }
    [Parameter] public bool ShowOcrOverlay { get; set; } = false;

    private PackageDrawing? drawing;
    private bool isLoading = true;
    private string? errorMessage = null;
    private string containerId = $"nutrient-container-{Guid.NewGuid():N}";
    private string fullscreenContainerId = $"fullscreen-wrapper-{Guid.NewGuid():N}";
    private bool isFullscreen = false;

    // Nutrient license key - Development license with full features including Document Editor for calibration saving
    // License includes: Webviewer + Annotation + Comments & Replies + Content Editor + Document Editor + Measurement tools
    private string licenseKey = "0D8AjKw9jGNdbWXn4JuDDwXVzN6ZSL76NEVWU-A4Y99C8w3THXzIxgncCIBrePSL8qVAFiwszAUotFXjPkfwAr2A1y5hq_Tj-poiQNtLJVhnUudMaeGTVuIG_fbRc5KHQpUFBKnlaBnpXfVlopPjmKa8oDdG_tYfvSIv7Cv802oIRjjEwXfSjw0w8vAFnSqhgMO65NT-df7pljLwhHCkGSgXXQte3vTzi4xzhWJxGBUSDko1iE37nLLwJoZtdLJRxIZAQOJR85LkCnZ9GZXJkZDGciMbam2H3w9wD_50wDB3oGQFSm8aXEZCKS-hsRNV_6dHjSHcAU3xpihrzrrcAzuRDY6ilO5xQvQP";

    private DotNetObjectReference<NutrientPdfViewer>? dotNetRef;
    private bool hasRendered = false;
    private bool initializationAttempted = false;
    private bool needsToLoadPdf = false;
    private string? pdfUrlToLoad = null;

    // Catalogue integration
    private bool sidebarVisible = true;
    private bool measurementPanelVisible = true;
    private CatalogueItem? selectedCatalogueItem = null;

    // PDF LOCK SYSTEM - Lock management fields
    private string sessionId = Guid.NewGuid().ToString();
    private bool isEditMode = false;
    private PdfEditLock? currentLock = null;
    private PdfEditLock? activeLock = null; // Lock held by another user (for banner)
    private Timer? heartbeatTimer;
    private Timer? inactivityWarningTimer;
    private DateTime lastActivityTime = DateTime.UtcNow;
    private int currentUserId;
    private string currentUserName = "Unknown User";
    private int currentCompanyId = 1; // Retrieved from authenticated user, defaults to 1
    private bool disposed = false;
    private bool isSaving = false; // Flag to prevent modal close during save
    private TakeoffMeasurementPanel? measurementPanel;

    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("[NutrientPdfViewer] OnInitializedAsync started for PackageDrawingId {PackageDrawingId}", PackageDrawingId);

        // Skip database loading if using data URL (upload modal scenario)
        if (!string.IsNullOrEmpty(PdfDataUrl))
        {
            Logger.LogInformation("[NutrientPdfViewer] Using PdfDataUrl - skipping database drawing load");
            // Create a dummy drawing object for upload modal
            drawing = new PackageDrawing
            {
                DrawingNumber = "Upload Preview",
                DrawingTitle = "File Upload"
            };
        }
        else
        {
            await LoadDrawing();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            Logger.LogInformation("[NutrientPdfViewer] OnAfterRenderAsync firstRender - drawing={DrawingExists}", drawing != null);

            // If drawing already loaded, initialize now
            if (drawing != null && !initializationAttempted)
            {
                Logger.LogInformation("[NutrientPdfViewer] Drawing ready, initializing viewer");
                await InitializeViewer();
            }
            else if (drawing == null)
            {
                Logger.LogInformation("[NutrientPdfViewer] Waiting for drawing to load...");
            }
        }
        else if (needsToLoadPdf && !string.IsNullOrEmpty(pdfUrlToLoad))
        {
            // DOM has been updated after StateHasChanged, now we can safely load the PDF
            Logger.LogInformation("[NutrientPdfViewer] OnAfterRenderAsync - DOM updated, loading PDF now");
            needsToLoadPdf = false;

            try
            {
                var loadResult = await JS.InvokeAsync<JsonElement>("nutrientViewer.loadPdf",
                    containerId,
                    pdfUrlToLoad,
                    isEditMode);

                // Check if load failed immediately (not async failure)
                if (loadResult.TryGetProperty("success", out var loadSuccess) && !loadSuccess.GetBoolean())
                {
                    if (loadResult.TryGetProperty("error", out var errorProp))
                    {
                        errorMessage = errorProp.GetString();
                        Logger.LogError("[NutrientPdfViewer] PDF load failed: {Error}", errorMessage);
                    }
                    StateHasChanged();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "[NutrientPdfViewer] Error loading PDF in OnAfterRenderAsync");
                errorMessage = $"Error loading PDF: {ex.Message}";
                StateHasChanged();
            }
        }
    }

    private async Task InitializeViewer()
    {
        if (initializationAttempted)
        {
            Logger.LogWarning("[NutrientPdfViewer] Initialization already attempted, skipping");
            return;
        }

        initializationAttempted = true;
        Logger.LogInformation("[NutrientPdfViewer] Starting viewer initialization");

        try
        {
            // STEP 1: Initialize lock system FIRST (before loading PDF)
            if (PackageDrawingId > 0)
            {
                Logger.LogInformation("[NutrientPdfViewer] Initializing lock system before PDF load...");
                await InitializeLockSystemAsync();
                Logger.LogInformation("[NutrientPdfViewer] Lock system initialized - isEditMode={IsEditMode}", isEditMode);
            }

            // Create DotNet reference for JavaScript callbacks
            dotNetRef = DotNetObjectReference.Create(this);
            Logger.LogInformation("[NutrientPdfViewer] DotNetObjectReference created");

            // Initialize Nutrient viewer (lightweight - just stores license key and dotNetRef)
            Logger.LogInformation("[NutrientPdfViewer] Calling nutrientViewer.initialize with containerId={ContainerId}", containerId);
            var initResult = await JS.InvokeAsync<JsonElement>("nutrientViewer.initialize",
                containerId,
                licenseKey,
                dotNetRef);

            if (initResult.TryGetProperty("success", out var successProp) && successProp.GetBoolean())
            {
                Logger.LogInformation("[NutrientPdfViewer] Nutrient initialized successfully");

                // Set loading to false to render the container div
                isLoading = false;

                // Determine PDF source: Data URL (upload modal) or API endpoint (normal drawings)
                if (!string.IsNullOrEmpty(PdfDataUrl))
                {
                    pdfUrlToLoad = PdfDataUrl;
                    Logger.LogInformation("[NutrientPdfViewer] Using data URL for PDF (upload modal scenario)");
                }
                else if (PackageDrawingId > 0)
                {
                    pdfUrlToLoad = $"/api/packagedrawings/{PackageDrawingId}/sharepoint-content";
                    Logger.LogInformation("[NutrientPdfViewer] Using SharePoint API endpoint for PDF (drawing {DrawingId}) - isEditMode={IsEditMode}", PackageDrawingId, isEditMode);
                }

                needsToLoadPdf = true;

                Logger.LogInformation("[NutrientPdfViewer] Triggering StateHasChanged to render container");
                StateHasChanged();

                // OnAfterRenderAsync will be called after the DOM updates, and will load the PDF
            }
            else
            {
                if (initResult.TryGetProperty("error", out var errorProp))
                {
                    errorMessage = errorProp.GetString();
                }
                else
                {
                    errorMessage = "Failed to initialize Nutrient viewer";
                }
                Logger.LogError("[NutrientPdfViewer] Initialization failed: {Error}", errorMessage);
                isLoading = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error initializing Nutrient viewer");
            errorMessage = $"Error initializing PDF viewer: {ex.Message}";
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadDrawing()
    {
        try
        {
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            drawing = await dbContext.PackageDrawings
                .Include(pd => pd.Package)
                .FirstOrDefaultAsync(pd => pd.Id == PackageDrawingId);

            if (drawing != null)
            {
                Logger.LogInformation("[NutrientPdfViewer] Drawing loaded: {DrawingNumber}", drawing.DrawingNumber);

                // If we've already rendered, initialize now
                if (hasRendered && !initializationAttempted)
                {
                    Logger.LogInformation("[NutrientPdfViewer] Drawing loaded after render, initializing now");
                    await InitializeViewer();
                }
            }
            else
            {
                Logger.LogWarning("[NutrientPdfViewer] Drawing not found for ID: {PackageDrawingId}", PackageDrawingId);
                errorMessage = "Drawing not found";
                isLoading = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error loading drawing");
            errorMessage = $"Error loading drawing: {ex.Message}";
            isLoading = false;
        }
    }

    // Panel toggle methods
    private void ToggleSidebar()
    {
        Logger.LogInformation("[NutrientPdfViewer] ToggleSidebar CALLED - Current sidebarVisible: {Current}", sidebarVisible);
        sidebarVisible = !sidebarVisible;
        Logger.LogInformation("[NutrientPdfViewer] ToggleSidebar - New sidebarVisible: {New}", sidebarVisible);
        StateHasChanged(); // CRITICAL: Force re-render to pass new value to child component
    }

    private async Task ToggleMeasurementPanel()
    {
        measurementPanelVisible = !measurementPanelVisible;
        Logger.LogInformation("[NutrientPdfViewer] ========================================");
        Logger.LogInformation("[NutrientPdfViewer] Measurement panel toggled: {Visible}", measurementPanelVisible);
        StateHasChanged();

        // CRITICAL: Update modal positioning when measurement panel visibility changes
        // Call immediately to start positioning updates
        await Task.Delay(50); // Wait for DOM render
        try
        {
            await JS.InvokeVoidAsync("updateModalAndFooterPositions");
            Logger.LogInformation("[NutrientPdfViewer] ‚úÖ Called updateModalAndFooterPositions IMMEDIATELY");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] ‚ùå Error calling updateModalAndFooterPositions immediately");
        }

        // Wait for CSS transition to complete (footer has 0.3s transform transition)
        await Task.Delay(300); // Wait for 0.3s transition
        try
        {
            await JS.InvokeVoidAsync("updateModalAndFooterPositions");
            Logger.LogInformation("[NutrientPdfViewer] ‚úÖ Called updateModalAndFooterPositions AFTER TRANSITION");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] ‚ùå Error calling updateModalAndFooterPositions after transition");
        }

        Logger.LogInformation("[NutrientPdfViewer] Called JavaScript to update modal positions after measurement panel toggle");
        Logger.LogInformation("[NutrientPdfViewer] ========================================");
    }

    /// <summary>
    /// Called when the measurement panel's visibility changes (from the child component's TogglePanel button)
    /// </summary>
    private async Task OnMeasurementPanelVisibilityChanged(bool isVisible)
    {
        Logger.LogInformation("[NutrientPdfViewer] ========================================");
        Logger.LogInformation("[NutrientPdfViewer] OnMeasurementPanelVisibilityChanged called: {IsVisible}", isVisible);

        measurementPanelVisible = isVisible;
        StateHasChanged();

        // CRITICAL: Update modal positioning when measurement panel visibility changes
        // Call immediately to start positioning updates
        await Task.Delay(50); // Wait for DOM render
        try
        {
            await JS.InvokeVoidAsync("updateModalAndFooterPositions");
            Logger.LogInformation("[NutrientPdfViewer] ‚úÖ Called updateModalAndFooterPositions IMMEDIATELY");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] ‚ùå Error calling updateModalAndFooterPositions immediately");
        }

        // Wait for CSS transition to complete (footer has 0.3s transform transition)
        await Task.Delay(300); // Wait for 0.3s transition
        try
        {
            await JS.InvokeVoidAsync("updateModalAndFooterPositions");
            Logger.LogInformation("[NutrientPdfViewer] ‚úÖ Called updateModalAndFooterPositions AFTER TRANSITION");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] ‚ùå Error calling updateModalAndFooterPositions after transition");
        }

        Logger.LogInformation("[NutrientPdfViewer] ========================================");
    }

    private async Task OpenFullMeasurementsPage()
    {
        try
        {
            if (drawing?.PackageId == null)
            {
                Logger.LogWarning("[NutrientPdfViewer] Cannot open measurements page - package ID not available");
                return;
            }

            var tenantSlug = await TenantService.GetCurrentTenantSlugAsync() ?? "default";
            var url = $"/{tenantSlug}/trace/packages/{drawing.PackageId}/drawings/{PackageDrawingId}/measurements";
            Logger.LogInformation("[NutrientPdfViewer] Opening measurements page in new window: {Url}", url);

            // Open in new window/tab using JavaScript
            await JS.InvokeVoidAsync("open", url, "_blank");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error opening measurements page");
        }
    }

    private async Task ToggleFullscreen()
    {
        try
        {
            if (!isFullscreen)
            {
                // Enter fullscreen
                Logger.LogInformation("[NutrientPdfViewer] Entering fullscreen mode");
                await JS.InvokeVoidAsync("nutrientViewer.enterFullscreen", fullscreenContainerId);
                isFullscreen = true;
            }
            else
            {
                // Exit fullscreen
                Logger.LogInformation("[NutrientPdfViewer] Exiting fullscreen mode");
                await JS.InvokeVoidAsync("nutrientViewer.exitFullscreen");
                isFullscreen = false;
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error toggling fullscreen");
        }
    }

    // Catalogue event handlers
    private async Task OnCatalogueItemSelected(CatalogueItem? item)
    {
        selectedCatalogueItem = item;
        Logger.LogInformation("[NutrientPdfViewer] Catalogue item selected: {ItemCode} - Category: {Category}",
            item?.ItemCode, item?.Category);

        // Pass selected item to JavaScript so it knows what to calculate when measurement is made
        // AND to auto-select the trace color based on category
        if (item != null && dotNetRef != null)
        {
            try
            {
                await JS.InvokeVoidAsync("nutrientViewer.setSelectedCatalogueItem",
                    containerId, item.Id, item.ItemCode, item.Description, item.Category);

                Logger.LogInformation("[NutrientPdfViewer] Sent catalogue item to JavaScript with category '{Category}' for color mapping",
                    item.Category);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "[NutrientPdfViewer] Error setting selected catalogue item in JavaScript");
            }
        }
        else if (item == null && dotNetRef != null)
        {
            // Clear selection
            try
            {
                await JS.InvokeVoidAsync("nutrientViewer.clearSelectedCatalogueItem", containerId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "[NutrientPdfViewer] Error clearing selected catalogue item in JavaScript");
            }
        }
    }

    private async Task OnMeasurementSaved()
    {
        Logger.LogInformation("[NutrientPdfViewer] Measurement saved, refreshing data");
        // Additional refresh logic if needed
    }

    // JavaScript callbacks
    [JSInvokable]
    public async Task OnPdfLoaded(int pageCount)
    {
        Logger.LogInformation("[NutrientPdfViewer] PDF loaded successfully with {PageCount} pages", pageCount);
        isLoading = false;

        // Render OCR overlay if provided (upload modal scenario)
        if (ShowOcrOverlay && OcrResult != null)
        {
            Logger.LogInformation("[NutrientPdfViewer] Rendering OCR overlay with {Count} fields", OcrResult.ExtractedFields.Count);
            await RenderOcrBoundingBoxes();
        }

        // Auto-restore calibration and annotations for normal drawings
        if (PackageDrawingId > 0)
        {
            await RestorePdfState();
        }

        StateHasChanged();
    }

    [JSInvokable]
    public Task OnPdfLoadError(string error)
    {
        Logger.LogError("[NutrientPdfViewer] PDF load error: {Error}", error);
        errorMessage = $"Failed to load PDF: {error}";
        isLoading = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnAnnotationCreated(JsonElement annotationData)
    {
        Logger.LogInformation("[NutrientPdfViewer] Annotation created");

        // Reset inactivity timer - user is actively making changes
        await ResetInactivityTimerAsync();

        try
        {
            // Extract annotation data
            var id = annotationData.GetProperty("id").GetString();
            var type = annotationData.GetProperty("type").GetString();
            var pageIndex = annotationData.GetProperty("pageIndex").GetInt32();
            var isMeasurement = annotationData.TryGetProperty("isMeasurement", out var isMeasurementProp) && isMeasurementProp.GetBoolean();

            Logger.LogInformation("[NutrientPdfViewer] Annotation: id={Id}, type={Type}, page={Page}, isMeasurement={IsMeasurement}",
                id, type, pageIndex, isMeasurement);

            // Auto-save annotation to database
            await SaveAnnotationToDatabase(annotationData);

            // Check if this is a calibration annotation (measurement with scale configuration)
            if (isMeasurement && annotationData.TryGetProperty("scale", out var scaleElement))
            {
                Logger.LogInformation("[NutrientPdfViewer] Calibration annotation detected - data: {Data}", annotationData.ToString());
                await SaveCalibrationFromAnnotation(annotationData, pageIndex);
            }
            else if (isMeasurement)
            {
                Logger.LogInformation("[NutrientPdfViewer] Measurement annotation created - data: {Data}", annotationData.ToString());
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error processing annotation");
        }
    }

    [JSInvokable]
    public async Task OnAnnotationUpdated(JsonElement annotationData)
    {
        Logger.LogInformation("[NutrientPdfViewer] Annotation updated");

        // Reset inactivity timer - user is actively making changes
        await ResetInactivityTimerAsync();

        // TODO: Update annotation in database
    }

    [JSInvokable]
    public async Task<string> OnAnnotationDeleted(string annotationId)
    {
        await JS.InvokeVoidAsync("console.log", "[C# OnAnnotationDeleted] ============================================");
        await JS.InvokeVoidAsync("console.log", $"[C# OnAnnotationDeleted] Method called with annotation ID: {annotationId}");

        Logger.LogInformation("[NutrientPdfViewer] ============================================");
        Logger.LogInformation("[NutrientPdfViewer] OnAnnotationDeleted called from JavaScript");
        Logger.LogInformation("[NutrientPdfViewer] Annotation ID: {AnnotationId}", annotationId);

        // Reset inactivity timer - user is actively making changes
        await ResetInactivityTimerAsync();

        try
        {
            await JS.InvokeVoidAsync("console.log", "[C# OnAnnotationDeleted] About to call DeleteAnnotationAsync...");
            Logger.LogInformation("[NutrientPdfViewer] Calling DeleteAnnotationAsync...");

            var result = await CalibrationService.DeleteAnnotationAsync(annotationId, currentCompanyId);

            await JS.InvokeVoidAsync("console.log", $"[C# OnAnnotationDeleted] DeleteAnnotationAsync returned: {result}");
            Logger.LogInformation("[NutrientPdfViewer] DeleteAnnotationAsync returned: {Result}", result);

            if (result)
            {
                await JS.InvokeVoidAsync("console.log", "[C# OnAnnotationDeleted] ‚úì Annotation deleted from database, refreshing panel...");
                Logger.LogInformation("[NutrientPdfViewer] ‚úì Annotation {AnnotationId} deleted from database", annotationId);

                // Refresh measurement panel to reflect the deletion
                Logger.LogInformation("[NutrientPdfViewer] Refreshing measurement panel (panel exists: {Exists})", measurementPanel != null);
                if (measurementPanel != null)
                {
                    await InvokeAsync(async () =>
                    {
                        Logger.LogInformation("[NutrientPdfViewer] Calling RefreshMeasurementsAsync...");
                        await measurementPanel.RefreshMeasurementsAsync();
                        StateHasChanged();
                        Logger.LogInformation("[NutrientPdfViewer] ‚úì Measurement panel refreshed");
                    });
                }

                await JS.InvokeVoidAsync("console.log", "[C# OnAnnotationDeleted] ‚úì Panel refreshed successfully");
            }
            else
            {
                await JS.InvokeVoidAsync("console.log", $"[C# OnAnnotationDeleted] ‚úó Annotation {annotationId} not found or not deleted");
                Logger.LogWarning("[NutrientPdfViewer] ‚úó Annotation {AnnotationId} not found or not deleted", annotationId);
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"[C# OnAnnotationDeleted] ERROR: {ex.Message}");
            await JS.InvokeVoidAsync("console.error", $"[C# OnAnnotationDeleted] Stack trace: {ex.StackTrace}");
            Logger.LogError(ex, "[NutrientPdfViewer] Error deleting annotation from database");
            return $"ERROR: {ex.Message}";
        }

        await JS.InvokeVoidAsync("console.log", "[C# OnAnnotationDeleted] ============================================");
        Logger.LogInformation("[NutrientPdfViewer] ============================================");
        return $"Processed deletion for annotation: {annotationId}";
    }

    /// <summary>
    /// Called from JavaScript when a PDF annotation is clicked (click-to-highlight feature).
    /// Forwards the selection to TakeoffMeasurementPanel to highlight the corresponding measurement row.
    /// Also broadcasts via SignalR for multi-tab support (full view mode).
    /// </summary>
    [JSInvokable]
    public async Task OnAnnotationSelected(string annotationId)
    {
        Logger.LogInformation("[NutrientPdfViewer] üñ±Ô∏è Annotation selected: {AnnotationId}", annotationId);

        // Forward to local measurement panel (if docked on right side)
        if (measurementPanel != null)
        {
            await measurementPanel.OnAnnotationSelected(annotationId);
            Logger.LogInformation("[NutrientPdfViewer] ‚úì Forwarded to local measurement panel");
        }

        // Broadcast via SignalR for full view mode (separate tab/window)
        if (PackageDrawingId > 0)
        {
            await MeasurementHubService.NotifyAnnotationSelectedAsync(PackageDrawingId, annotationId);
            Logger.LogInformation("[NutrientPdfViewer] ‚úì Broadcasted annotation selection via SignalR");
        }
    }

    /// <summary>
    /// Called from JavaScript when calibration scale is updated through PSPDFKit's native calibration tool
    /// </summary>
    [JSInvokable]
    public async Task OnCalibrationUpdated(decimal scaleRatio, string unit, int pageIndex)
    {
        Logger.LogInformation("[NutrientPdfViewer] ============================================");
        Logger.LogInformation("[NutrientPdfViewer] CALIBRATION UPDATED via annotationPresets.update event");
        Logger.LogInformation("[NutrientPdfViewer] Scale: 1:{ScaleRatio} ({Unit})", scaleRatio, unit);
        Logger.LogInformation("[NutrientPdfViewer] Page: {PageIndex}", pageIndex);
        Logger.LogInformation("[NutrientPdfViewer] PackageDrawingId: {DrawingId}", PackageDrawingId);
        Logger.LogInformation("[NutrientPdfViewer] ============================================");

        try
        {
            int? userId = currentUserId > 0 ? currentUserId : null;

            // Save calibration to database
            await CalibrationService.SaveCalibrationAsync(
                PackageDrawingId,
                scaleRatio,
                unit,
                knownDistance: null,  // Not available from preset update
                measuredDistance: null,  // Not available from preset update
                pageIndex,
                calibrationLineStart: null,
                calibrationLineEnd: null,
                userId,
                currentCompanyId
            );

            Logger.LogInformation("[NutrientPdfViewer] ‚úì Calibration saved to database: Scale 1:{Scale} ({Unit})", scaleRatio, unit);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error saving calibration from preset update");
        }
    }

    [JSInvokable]
    public async Task OnMeasurementCalculated(JsonElement calculationResult)
    {
        Logger.LogInformation("[NutrientPdfViewer] ============================================");
        Logger.LogInformation("[NutrientPdfViewer] OnMeasurementCalculated CALLED");
        Logger.LogInformation("[NutrientPdfViewer] Raw JSON: {Json}", calculationResult.GetRawText());

        try
        {
            // Deserialize the calculation result (case-insensitive to handle JavaScript camelCase)
            var options = new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var result = System.Text.Json.JsonSerializer.Deserialize<MeasurementCalculationResult>(calculationResult.GetRawText(), options);

            Logger.LogInformation("[NutrientPdfViewer] Deserialization successful: {Success}", result != null);
            if (result != null)
            {
                Logger.LogInformation("[NutrientPdfViewer] Deserialized values - ItemCode: {ItemCode}, CatalogueItemId: {CatalogueItemId}, Weight: {Weight}",
                    result.ItemCode, result.CatalogueItemId, result.Weight);
            }
            Logger.LogInformation("[NutrientPdfViewer] Measurement panel reference: {Exists}", measurementPanel != null);

            if (result != null && measurementPanel != null)
            {
                Logger.LogInformation("[NutrientPdfViewer] Forwarding calculation to measurement panel:");
                Logger.LogInformation("[NutrientPdfViewer]   - ItemCode: {ItemCode}", result.ItemCode);
                Logger.LogInformation("[NutrientPdfViewer]   - Weight: {Weight} kg", result.Weight);

                // Forward to measurement panel to display
                await measurementPanel.ShowMeasurementResult(result);

                Logger.LogInformation("[NutrientPdfViewer] Successfully forwarded to measurement panel");
            }
            else
            {
                Logger.LogWarning("[NutrientPdfViewer] Cannot show measurement result:");
                Logger.LogWarning("[NutrientPdfViewer]   - Result null: {ResultNull}", result == null);
                Logger.LogWarning("[NutrientPdfViewer]   - Panel null: {PanelNull}", measurementPanel == null);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error processing measurement calculation");
            Logger.LogError("[NutrientPdfViewer] Exception message: {Message}", ex.Message);
            Logger.LogError("[NutrientPdfViewer] Exception stack: {Stack}", ex.StackTrace);
        }

        Logger.LogInformation("[NutrientPdfViewer] ============================================");
    }

    /// <summary>
    /// Restore complete PDF state from Instant JSON (includes all annotations + calibration)
    /// Uses calibration config separately to work with trial license
    /// </summary>
    private async Task RestorePdfState()
    {
        try
        {
            Logger.LogInformation("[NutrientPdfViewer] Restoring PDF state for drawing {DrawingId}", PackageDrawingId);

            await using var dbContext = await DbContextFactory.CreateDbContextAsync();

            // Load the drawing with its saved Instant JSON and calibration config
            var drawingWithState = await dbContext.PackageDrawings
                .AsNoTracking()
                .FirstOrDefaultAsync(pd => pd.Id == PackageDrawingId);

            if (drawingWithState != null)
            {
                // Restore calibration config first (works with trial license using setAnnotationPresets())
                if (!string.IsNullOrEmpty(drawingWithState.CalibrationConfig))
                {
                    Logger.LogInformation("[NutrientPdfViewer] Restoring calibration config ({Length} chars)...",
                        drawingWithState.CalibrationConfig.Length);

                    try
                    {
                        var calibrationResult = await JS.InvokeAsync<JsonElement>("nutrientViewer.importMeasurementConfig",
                            containerId, drawingWithState.CalibrationConfig);

                        if (calibrationResult.TryGetProperty("success", out var calibrationSuccess) && calibrationSuccess.GetBoolean())
                        {
                            Logger.LogInformation("[NutrientPdfViewer] ‚úì Calibration config restored successfully");
                        }
                        else
                        {
                            Logger.LogWarning("[NutrientPdfViewer] Failed to restore calibration config");
                            if (calibrationResult.TryGetProperty("error", out var error))
                            {
                                Logger.LogWarning("[NutrientPdfViewer] Error: {Error}", error.GetString());
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "[NutrientPdfViewer] Error restoring calibration config");
                    }
                }

                // Try to restore Instant JSON (annotations) - may fail with trial license
                if (!string.IsNullOrEmpty(drawingWithState.InstantJson))
                {
                    Logger.LogInformation("[NutrientPdfViewer] Found saved annotations ({Length} chars) - attempting to restore...",
                        drawingWithState.InstantJson.Length);

                    try
                    {
                        var result = await JS.InvokeAsync<JsonElement>("nutrientViewer.importAnnotations",
                            containerId, drawingWithState.InstantJson);

                        if (result.TryGetProperty("success", out var success) && success.GetBoolean())
                        {
                            Logger.LogInformation("[NutrientPdfViewer] ‚úì Annotations restored successfully");
                        }
                        else
                        {
                            Logger.LogWarning("[NutrientPdfViewer] Failed to restore annotations (this is expected with trial license)");
                            if (result.TryGetProperty("error", out var error))
                            {
                                Logger.LogWarning("[NutrientPdfViewer] Error: {Error}", error.GetString());
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "[NutrientPdfViewer] Error importing annotations (expected with trial license)");
                    }
                }

                if (string.IsNullOrEmpty(drawingWithState.InstantJson) && string.IsNullOrEmpty(drawingWithState.CalibrationConfig))
                {
                    Logger.LogInformation("[NutrientPdfViewer] No saved state found - this is a new drawing");
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error restoring PDF state");
        }
    }

    /// <summary>
    /// Save annotation to database (called from annotation events)
    /// </summary>
    private async Task SaveAnnotationToDatabase(JsonElement annotationData)
    {
        try
        {
            int? userId = currentUserId > 0 ? currentUserId : null;

            var annotationId = annotationData.GetProperty("id").GetString();
            var annotationType = annotationData.GetProperty("type").GetString();
            var pageIndex = annotationData.GetProperty("pageIndex").GetInt32();
            var isMeasurement = annotationData.TryGetProperty("isMeasurement", out var isMeasurementProp) && isMeasurementProp.GetBoolean();

            // Export Instant JSON for this annotation
            var instantJson = await JS.InvokeAsync<string>("nutrientViewer.exportAnnotations", containerId);

            if (!string.IsNullOrEmpty(instantJson))
            {
                await CalibrationService.SaveAnnotationAsync(
                    PackageDrawingId,
                    annotationId ?? Guid.NewGuid().ToString(),
                    annotationType ?? "Unknown",
                    pageIndex,
                    instantJson,
                    isMeasurement,
                    false, // isCalibration - would need to detect from annotation type
                    null, // traceTakeoffMeasurementId - would be set when measurement is saved
                    userId,
                    currentCompanyId
                );

                Logger.LogInformation("[NutrientPdfViewer] ‚úì Annotation {AnnotationId} saved to database", annotationId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error saving annotation to database");
        }
    }

    /// <summary>
    /// Save calibration from annotation data when scale configuration is detected
    /// </summary>
    private async Task SaveCalibrationFromAnnotation(JsonElement annotationData, int pageIndex)
    {
        try
        {
            int? userId = currentUserId > 0 ? currentUserId : null;

            // Extract scale configuration from annotation data
            if (!annotationData.TryGetProperty("scale", out var scaleElement))
            {
                Logger.LogWarning("[NutrientPdfViewer] No scale configuration found in annotation data");
                return;
            }

            // Parse scale object
            decimal scale = 50m; // Default 1:50
            string unit = "m"; // Default meters
            decimal? knownDistance = null;
            decimal? measuredDistance = null;
            string? calibrationLineStart = null;
            string? calibrationLineEnd = null;

            // Extract scale ratio (e.g., 50 for 1:50)
            if (scaleElement.TryGetProperty("from", out var fromElement))
            {
                scale = fromElement.GetDecimal();
            }

            // Extract unit
            if (scaleElement.TryGetProperty("unitFrom", out var unitElement))
            {
                unit = unitElement.GetString() ?? "m";
            }

            // Extract measurement value if available
            if (annotationData.TryGetProperty("value", out var valueElement))
            {
                measuredDistance = valueElement.GetDecimal();
            }

            // Extract line coordinates if available
            if (annotationData.TryGetProperty("coordinates", out var coordinatesElement) &&
                coordinatesElement.TryGetProperty("type", out var coordTypeElement) &&
                coordTypeElement.GetString() == "lines" &&
                coordinatesElement.TryGetProperty("data", out var dataElement))
            {
                var lines = dataElement.EnumerateArray().ToArray();
                if (lines.Length > 0)
                {
                    var line = lines[0];
                    if (line.TryGetProperty("start", out var startElement) &&
                        line.TryGetProperty("end", out var endElement))
                    {
                        calibrationLineStart = System.Text.Json.JsonSerializer.Serialize(startElement);
                        calibrationLineEnd = System.Text.Json.JsonSerializer.Serialize(endElement);
                    }
                }
            }

            // Calculate known distance based on scale and measured distance
            if (measuredDistance.HasValue && scale > 0)
            {
                knownDistance = measuredDistance.Value * scale;
            }

            Logger.LogInformation("[NutrientPdfViewer] Saving calibration: Scale 1:{Scale} ({Unit}), KnownDistance={KnownDistance}, MeasuredDistance={MeasuredDistance}",
                scale, unit, knownDistance, measuredDistance);

            // Save calibration to database
            await CalibrationService.SaveCalibrationAsync(
                PackageDrawingId,
                scale,
                unit,
                knownDistance,
                measuredDistance,
                pageIndex,
                calibrationLineStart,
                calibrationLineEnd,
                userId,
                currentCompanyId
            );

            Logger.LogInformation("[NutrientPdfViewer] ‚úì Calibration saved to database: Scale 1:{Scale} ({Unit})", scale, unit);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error saving calibration from annotation");
        }
    }

    /// <summary>
    /// Render OCR bounding boxes as green rectangles on the PDF
    /// </summary>
    private async Task RenderOcrBoundingBoxes()
    {
        if (OcrResult?.ExtractedFields == null || !OcrResult.ExtractedFields.Any())
        {
            Logger.LogWarning("[NutrientPdfViewer] No OCR fields to render");
            return;
        }

        try
        {
            Logger.LogInformation("[NutrientPdfViewer] Rendering {Count} OCR bounding boxes", OcrResult.ExtractedFields.Count);

            foreach (var field in OcrResult.ExtractedFields)
            {
                if (field.Bounds == null) continue;

                await JS.InvokeVoidAsync("nutrientViewer.addOcrRectangle",
                    containerId,
                    field.Bounds.X,
                    field.Bounds.Y,
                    field.Bounds.Width,
                    field.Bounds.Height,
                    field.FieldName,
                    field.Value,
                    field.Confidence);
            }

            Logger.LogInformation("[NutrientPdfViewer] ‚úì OCR overlay rendered successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error rendering OCR bounding boxes");
        }
    }

    /// <summary>
    /// Handle the Close button click - export PDF, show progress, AWAIT SharePoint upload, then close
    /// CRITICAL: Must await SharePoint upload to prevent race condition where user reopens PDF before upload completes
    /// </summary>
    private async Task HandleCloseAsync()
    {
        // Prevent multiple simultaneous saves
        if (isSaving)
        {
            Logger.LogWarning("[NutrientPdfViewer] Save already in progress, ignoring duplicate click");
            return;
        }

        isSaving = true;
        StateHasChanged(); // Update UI to show "Saving..." button state

        Logger.LogInformation("[NutrientPdfViewer] ========================================");
        Logger.LogInformation("[NutrientPdfViewer] HandleCloseAsync CALLED - Button clicked!");
        Logger.LogInformation("[NutrientPdfViewer] isSaving=true");
        Logger.LogInformation("[NutrientPdfViewer] ========================================");

        try
        {
            if (PackageDrawingId > 0)
            {
                Logger.LogInformation("[NutrientPdfViewer] Starting close sequence for drawing {DrawingId}", PackageDrawingId);

                // Show progress indicator
                await JS.InvokeVoidAsync("showProgressIndicator", "Saving PDF changes...");

                // STEP 1: Export PDF with embedded annotations
                Logger.LogInformation("[NutrientPdfViewer] Step 1: Exporting PDF from JavaScript...");

                var pdfBase64 = await JS.InvokeAsync<string>("nutrientViewer.exportPDF", containerId);
                Logger.LogInformation("[NutrientPdfViewer] Exported PDF (base64): {Length} chars", pdfBase64?.Length ?? 0);

                // Convert base64 to bytes
                byte[]? pdfBytes = null;
                if (!string.IsNullOrEmpty(pdfBase64))
                {
                    try
                    {
                        pdfBytes = Convert.FromBase64String(pdfBase64);
                        Logger.LogInformation("[NutrientPdfViewer] Converted PDF to bytes: {Length} bytes", pdfBytes.Length);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "[NutrientPdfViewer] Error converting base64 to bytes");
                    }
                }

                // STEP 2: Update file in cloud storage (AWAIT this - critical!)
                if (pdfBytes != null && pdfBytes.Length > 0)
                {
                    await JS.InvokeVoidAsync("updateProgressIndicator", "Uploading to cloud storage...");
                    Logger.LogInformation("[NutrientPdfViewer] Step 2: Uploading to cloud storage via {Provider}...",
                        CloudStorage.ProviderName);

                    await using var dbContext = await DbContextFactory.CreateDbContextAsync();
                    var drawing = await dbContext.PackageDrawings
                        .FirstOrDefaultAsync(pd => pd.Id == PackageDrawingId);

                    if (drawing != null && !string.IsNullOrEmpty(drawing.SharePointItemId))
                    {
                        // Update the existing file in cloud storage - AWAIT this!
                        using var pdfStream = new MemoryStream(pdfBytes);
                        var updateResult = await CloudStorage.UpdateFileAsync(
                            drawing.SharePointItemId,
                            pdfStream,
                            "application/pdf"
                        );

                        Logger.LogInformation("[NutrientPdfViewer] ‚úì PDF updated in {Provider}: FileId={FileId}, Size={Size} bytes",
                            CloudStorage.ProviderName, updateResult.FileId, updateResult.Size);

                        // Clear Instant JSON and calibration config since they're now embedded in PDF
                        drawing.InstantJson = null;
                        drawing.InstantJsonLastUpdated = DateTime.UtcNow;
                        drawing.CalibrationConfig = null;
                        drawing.CalibrationConfigLastUpdated = DateTime.UtcNow;

                        await dbContext.SaveChangesAsync();
                        Logger.LogInformation("[NutrientPdfViewer] ‚úì Cleared Instant JSON (annotations embedded in PDF)");
                    }
                    else
                    {
                        Logger.LogWarning("[NutrientPdfViewer] Cannot update SharePoint file - SharePointItemId is null or empty");
                    }
                }

                // STEP 3: Release lock
                if (isEditMode && currentLock != null)
                {
                    await LockService.ReleaseLockAsync(sessionId);
                    await MeasurementHubService.NotifyLockReleasedAsync(PackageDrawingId, sessionId);
                    Logger.LogInformation("[NutrientPdfViewer] ‚úì Lock released");
                }

                // Hide progress indicator
                await JS.InvokeVoidAsync("hideProgressIndicator");

                // STEP 4: Close the modal
                Logger.LogInformation("[NutrientPdfViewer] Step 3: Closing modal...");
                await OnClose.InvokeAsync();

                // Show success toast
                await JS.InvokeVoidAsync("showToast", "PDF saved successfully", "success");
            }
            else
            {
                // No PackageDrawingId - just close the modal
                await OnClose.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error in HandleCloseAsync");

            // Hide progress indicator
            try
            {
                await JS.InvokeVoidAsync("hideProgressIndicator");
            }
            catch { }

            // Show error toast
            await JS.InvokeVoidAsync("showToast", $"Error saving PDF: {ex.Message}", "error");

            // Always try to close the modal even if there's an error
            try
            {
                await OnClose.InvokeAsync();
            }
            catch (Exception closeEx)
            {
                Logger.LogError(closeEx, "[NutrientPdfViewer] Error closing modal");
            }
        }
        finally
        {
            isSaving = false;
            Logger.LogInformation("[NutrientPdfViewer] isSaving=false, HandleCloseAsync completed");
        }
    }

    /// <summary>
    /// SIMPLIFIED TEST VERSION - just close the modal, no exports
    /// This tests if the SignalR circuit can handle the close operation
    /// </summary>
    private async Task HandleCloseTestAsync()
    {
        try
        {
            Logger.LogInformation("[NutrientPdfViewer] ========================================");
            Logger.LogInformation("[NutrientPdfViewer] SIMPLIFIED TEST CLOSE - START");
            Logger.LogInformation("[NutrientPdfViewer] PackageDrawingId: {DrawingId}", PackageDrawingId);
            Logger.LogInformation("[NutrientPdfViewer] ========================================");

            // Just close the modal - no exports, no database operations
            await OnClose.InvokeAsync();

            Logger.LogInformation("[NutrientPdfViewer] ‚úì Modal closed successfully (test mode)");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error in HandleCloseTestAsync");

            // Always try to close the modal even if there's an error
            try
            {
                await OnClose.InvokeAsync();
            }
            catch (Exception closeEx)
            {
                Logger.LogError(closeEx, "[NutrientPdfViewer] Error closing modal in test handler");
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (disposed) return;

        if (dotNetRef != null)
        {
            // Instant JSON is now saved in HandleCloseAsync(), before disposal
            // So we just need to unload the Nutrient instance here

            // Unload Nutrient instance
            try
            {
                await JS.InvokeVoidAsync("nutrientViewer.unload", containerId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "[NutrientPdfViewer] Error unloading Nutrient instance");
            }

            dotNetRef.Dispose();
        }

        // Release lock on dispose
        if (isEditMode && currentLock != null)
        {
            try
            {
                await LockService.ReleaseLockAsync(sessionId);
                await MeasurementHubService.NotifyLockReleasedAsync(PackageDrawingId, sessionId);
                Logger.LogInformation("[NutrientPdfViewer] Lock released in DisposeAsync");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "[NutrientPdfViewer] Error releasing lock in DisposeAsync");
            }
        }

        heartbeatTimer?.Dispose();
        inactivityWarningTimer?.Dispose();
        disposed = true;
    }

    // ========================================
    // PDF LOCK SYSTEM - METHODS
    // ========================================

    private async Task InitializeLockSystemAsync()
    {
        try
        {
            // For upload preview mode (PackageDrawingId == 0), skip lock system and enable edit mode
            if (PackageDrawingId == 0)
            {
                Logger.LogInformation("[NutrientPdfViewer] Upload preview mode - skipping lock system, enabling edit mode");
                isEditMode = true;
                return;
            }

            // Get current user info from authentication
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext?.User?.Identity?.IsAuthenticated == true)
            {
                var userIdClaim = httpContext.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier);
                var userNameClaim = httpContext.User.FindFirst(System.Security.Claims.ClaimTypes.Name);

                if (userIdClaim != null && int.TryParse(userIdClaim.Value, out int userId))
                {
                    currentUserId = userId;
                }

                if (userNameClaim != null)
                {
                    currentUserName = userNameClaim.Value;
                }
            }

            Logger.LogInformation("[NutrientPdfViewer] Initializing lock system: SessionId={SessionId}, UserId={UserId}, UserName={UserName}",
                sessionId, currentUserId, currentUserName);

            // Get company ID from authenticated user
            if (currentUserId > 0)
            {
                await using var dbContext = await DbContextFactory.CreateDbContextAsync();
                var user = await dbContext.Users.FindAsync(currentUserId);
                currentCompanyId = user?.CompanyId ?? 1; // Default to 1 if user has no company
                Logger.LogInformation("[NutrientPdfViewer] Retrieved CompanyId={CompanyId} for user {UserId}", currentCompanyId, currentUserId);
            }

            // Try to acquire edit lock
            currentLock = await LockService.TryAcquireLockAsync(
                PackageDrawingId,
                sessionId,
                currentUserId,
                currentUserName);

            isEditMode = (currentLock != null);

            if (isEditMode)
            {
                Logger.LogInformation("[NutrientPdfViewer] ‚úì Edit lock acquired: LockId={LockId}", currentLock!.Id);

                // Start heartbeat (every 30 seconds)
                heartbeatTimer = new Timer(async _ =>
                {
                    if (!disposed)
                    {
                        try
                        {
                            await LockService.UpdateHeartbeatAsync(sessionId);
                            Logger.LogDebug("[NutrientPdfViewer] Heartbeat sent");
                        }
                        catch (Exception ex)
                        {
                            Logger.LogError(ex, "[NutrientPdfViewer] Error sending heartbeat");
                        }
                    }
                }, null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));

                // Start inactivity monitor (check every minute)
                StartInactivityMonitor();

                // Notify others via SignalR
                await MeasurementHubService.NotifyLockAcquiredAsync(
                    PackageDrawingId, currentUserName, sessionId);
            }
            else
            {
                // Get info about who has the lock
                activeLock = await LockService.GetActiveLockAsync(PackageDrawingId);
                Logger.LogWarning("[NutrientPdfViewer] ‚úó Could not acquire lock - locked by {UserName}",
                    activeLock?.UserName ?? "Unknown");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error initializing lock system");
        }
    }

    private void StartInactivityMonitor()
    {
        inactivityWarningTimer = new Timer(async _ =>
        {
            if (disposed || !isEditMode) return;

            var inactiveMinutes = (DateTime.UtcNow - lastActivityTime).TotalMinutes;

            if (inactiveMinutes >= 10)
            {
                await HandleInactivityTimeoutAsync();
            }
            else if (inactiveMinutes >= 9)
            {
                await ShowInactivityWarningAsync(1);
            }
            else if (inactiveMinutes >= 8)
            {
                await ShowInactivityWarningAsync(2);
            }
        }, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
    }

    private async Task HandleInactivityTimeoutAsync()
    {
        Logger.LogWarning("[NutrientPdfViewer] ‚è∞ Inactivity timeout - switching to view-only mode");

        try
        {
            // Release lock
            if (currentLock != null)
            {
                await LockService.ReleaseLockAsync(sessionId);
                await MeasurementHubService.NotifyLockReleasedAsync(PackageDrawingId, sessionId);
            }

            // Switch to view-only mode
            isEditMode = false;
            await JS.InvokeVoidAsync("nutrientViewer.setViewOnlyMode", containerId);

            // Stop timers
            heartbeatTimer?.Dispose();
            heartbeatTimer = null;
            inactivityWarningTimer?.Dispose();
            inactivityWarningTimer = null;

            // Notify user
            await JS.InvokeVoidAsync("showToast",
                "You've been disconnected due to 10 minutes of inactivity. You are now in view-only mode.",
                "warning");

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NutrientPdfViewer] Error handling inactivity timeout");
        }
    }

    private async Task ShowInactivityWarningAsync(int minutesLeft)
    {
        await JS.InvokeVoidAsync("showToast",
            $"‚ö†Ô∏è You'll be disconnected in {minutesLeft} minute(s) due to inactivity. Make an annotation change to stay active.",
            "warning");
    }

    private async Task ResetInactivityTimerAsync()
    {
        lastActivityTime = DateTime.UtcNow;

        if (isEditMode && currentLock != null)
        {
            await LockService.UpdateActivityAsync(sessionId);
        }
    }

    private async Task TryAcquireEditMode()
    {
        await InitializeLockSystemAsync();
        await InvokeAsync(StateHasChanged);

        if (!isEditMode)
        {
            await JS.InvokeVoidAsync("showToast",
                $"Still locked by {activeLock?.UserName ?? "another user"}. Please try again later.",
                "warning");
        }
        else
        {
            // Reload PDF in edit mode
            var pdfUrl = $"/api/packagedrawings/{PackageDrawingId}/pdf";
            await JS.InvokeVoidAsync("nutrientViewer.loadPdf", containerId, pdfUrl, isEditMode);
        }
    }
}

<style>
    .nutrient-pdf-viewer {
        height: 100%;
        display: flex;
        flex-direction: column;
        background: #f5f5f5;
    }

    .loading-container, .error-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        gap: 1rem;
    }

    .loading-container .spinner-border {
        width: 3rem;
        height: 3rem;
        border: 0.3rem solid currentColor;
        border-right-color: transparent;
        border-radius: 50%;
        animation: spinner-border 0.75s linear infinite;
    }

    @@keyframes spinner-border {
        to { transform: rotate(360deg); }
    }

    .error-container i {
        font-size: 3rem;
        color: #dc3545;
    }

    .error-container h3 {
        margin: 0;
    }

    .error-container p {
        color: #666;
        max-width: 600px;
        text-align: center;
    }

    .nutrient-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: white;
        padding: 1rem;
        border-bottom: 1px solid #e0e0e0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .toolbar-section h3 {
        margin: 0;
        font-size: 1.25rem;
        color: #333;
    }

    .toolbar-section.tools {
        display: flex;
        gap: 1rem;
        align-items: center;
    }

    .tool-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .tool-group label {
        font-size: 0.75rem;
        text-transform: uppercase;
        color: #666;
        margin: 0;
    }

    .tool-btn {
        padding: 0.5rem 0.75rem;
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
    }

    .tool-btn:hover {
        background: #f5f5f5;
        border-color: #0d6efd;
    }

    .btn {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.2s;
    }

    .btn-primary {
        background: #0d6efd;
        color: white;
    }

    .btn-primary:hover {
        background: #0b5ed7;
    }

    .btn-secondary {
        background: #6c757d;
        color: white;
    }

    .btn-secondary:hover {
        background: #5c636a;
    }

    .nutrient-container-wrapper {
        flex: 1;
        overflow: hidden;
        background: #333;
    }

    .nutrient-pdf-container {
        width: 100%;
        height: 100%;
        background: white;
    }

    /* Fullscreen wrapper styles - always maintain flex layout */
    .fullscreen-wrapper {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0; /* Allow flex children to shrink */
    }

    /* Main content area - 3-column layout (sidebar, PDF, measurements) */
    .viewer-main-content {
        display: flex;
        flex-direction: row;
        flex: 1;
        min-height: 0;
        overflow: hidden;
    }

    /* Upload preview mode - full width PDF viewer without sidebars */
    .viewer-main-content.upload-preview-mode {
        display: block;
    }

    .viewer-main-content.upload-preview-mode .nutrient-container-wrapper {
        width: 100%;
        height: 100%;
    }

    /* When in fullscreen mode, apply full viewport sizing */
    .fullscreen-wrapper:fullscreen,
    .fullscreen-wrapper:-webkit-full-screen,
    .fullscreen-wrapper:-moz-full-screen,
    .fullscreen-wrapper:-ms-fullscreen {
        background: #f5f5f5;
        width: 100vw;
        height: 100vh;
    }

    /* Override catalogue sidebar positioning in fullscreen mode */
    .fullscreen-wrapper:fullscreen .takeoff-catalogue-sidebar,
    .fullscreen-wrapper:-webkit-full-screen .takeoff-catalogue-sidebar,
    .fullscreen-wrapper:-moz-full-screen .takeoff-catalogue-sidebar,
    .fullscreen-wrapper:-ms-fullscreen .takeoff-catalogue-sidebar {
        position: relative !important;
        left: 0 !important;
        top: 0 !important;
        height: 100%;
        flex-shrink: 0;
    }

    /* Override measurement panel positioning in fullscreen mode */
    .fullscreen-wrapper:fullscreen .takeoff-measurement-panel,
    .fullscreen-wrapper:-webkit-full-screen .takeoff-measurement-panel,
    .fullscreen-wrapper:-moz-full-screen .takeoff-measurement-panel,
    .fullscreen-wrapper:-ms-fullscreen .takeoff-measurement-panel {
        position: relative !important;
        right: 0 !important;
        top: 0 !important;
        height: 100%;
        flex-shrink: 0;
    }

    .btn-warning {
        background: #ffc107;
        color: #000;
    }

    .btn-warning:hover {
        background: #e0a800;
    }
</style>

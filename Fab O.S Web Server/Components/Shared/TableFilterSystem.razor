@typeparam TItem
@using FabOS.WebServer.Models.Filtering

<div class="table-filter-system">
    <div class="filter-bar">
        <div class="filter-bar-left">
            <button type="button" class="btn-filter @(isFilterPanelOpen ? "active" : "")" @onclick="ToggleFilterPanel">
                <i class="fas fa-filter"></i>
                <span>Filter</span>
                @if (activeFilters.Any())
                {
                    <span class="filter-badge">@activeFilters.Count</span>
                }
            </button>
            
            <div class="filter-search">
                <i class="fas fa-search filter-search-icon"></i>
                <input type="text" class="filter-search-input" 
                       placeholder="Quick search..."
                       @bind="quickSearchTerm"
                       @bind:event="oninput"
                       @onkeyup="HandleQuickSearch" />
                @if (!string.IsNullOrEmpty(quickSearchTerm))
                {
                    <button type="button" class="filter-search-clear" @onclick="ClearQuickSearch">
                        <i class="fas fa-times"></i>
                    </button>
                }
            </div>
        </div>
        
        <div class="filter-bar-right">
            <span class="results-count">
                <span>@FilteredItemCount</span> of <span>@TotalItemCount</span> items
            </span>
        </div>
    </div>
    
    @if (activeFilters.Any())
    {
        <div class="active-filters-row">
            @foreach (var filter in activeFilters)
            {
                <div class="filter-pill">
                    <span class="filter-pill-field">@filter.FieldName</span>
                    <span class="filter-pill-operator">@GetOperatorDisplay(filter.Operator)</span>
                    <span class="filter-pill-value">@filter.Value</span>
                    <button type="button" class="filter-pill-remove" @onclick="@(() => RemoveFilter(filter))">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            }
        </div>
    }
    
    @if (isFilterPanelOpen)
    {
        <div class="filter-panel">
            <div class="filter-rules">
                @foreach (var rule in filterRules)
                {
                    <div class="filter-rule">
                        @if (filterRules.IndexOf(rule) > 0)
                        {
                            <select class="filter-rule-operator" @bind="rule.LogicalOperator">
                                <option value="AND">AND</option>
                                <option value="OR">OR</option>
                            </select>
                        }
                        
                        <select class="filter-rule-field" @bind="rule.FieldName" @bind:after="@(() => OnFieldChanged(rule))">
                            <option value="">Select field...</option>
                            @foreach (var field in availableFields)
                            {
                                <option value="@field.PropertyName">@field.DisplayName</option>
                            }
                        </select>
                        
                        <select class="filter-rule-comparison" @bind="rule.Operator">
                            <option value="Equals">Equals</option>
                            <option value="NotEquals">Not Equals</option>
                            <option value="Contains">Contains</option>
                            <option value="StartsWith">Starts With</option>
                            <option value="EndsWith">Ends With</option>
                            <option value="GreaterThan">Greater Than</option>
                            <option value="LessThan">Less Than</option>
                            <option value="Between">Between</option>
                        </select>
                        
                        @if (rule.AvailableValues?.Any() == true)
                        {
                            <div class="filter-value-dropdown">
                                <input type="text" class="filter-rule-value" 
                                       @bind="rule.Value"
                                       @onfocus="@(() => ShowValueDropdown(rule))"
                                       @onblur="@(() => HideValueDropdown(rule))" />
                                @if (rule.ShowDropdown)
                                {
                                    <div class="filter-value-list">
                                        @foreach (var value in rule.AvailableValues)
                                        {
                                            <div class="filter-value-item @(value == rule.Value ? "selected" : "")"
                                                 @onmousedown="@(() => SelectValue(rule, value))">
                                                @value
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                        else
                        {
                            <input type="text" class="filter-rule-value" @bind="rule.Value" />
                        }
                        
                        <button type="button" class="filter-rule-remove" @onclick="@(() => RemoveRule(rule))">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                }
            </div>
            
            <button type="button" class="btn-add-filter" @onclick="AddRule">
                <i class="fas fa-plus"></i>
                Add Filter Rule
            </button>
            
            <div class="filter-actions">
                <button type="button" class="btn-apply-filters" @onclick="ApplyFilters">
                    <i class="fas fa-check"></i> Apply Filters
                </button>
                <button type="button" class="btn-clear-filters" @onclick="ClearAllFilters">
                    <i class="fas fa-times"></i> Clear All
                </button>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public List<TItem> Items { get; set; } = new();
    [Parameter] public EventCallback<List<FilterRule>> OnFiltersChanged { get; set; }
    [Parameter] public int FilteredItemCount { get; set; }
    [Parameter] public int TotalItemCount { get; set; }
    
    private bool isFilterPanelOpen = false;
    private string quickSearchTerm = "";
    private List<FilterRule> activeFilters = new();
    private List<FilterRuleViewModel> filterRules = new();
    private List<FilterFieldDefinition> availableFields = new();
    
    private class FilterRuleViewModel : FilterRule
    {
        public bool ShowDropdown { get; set; }
        public List<string>? AvailableValues { get; set; }
    }
    
    protected override void OnInitialized()
    {
        InitializeAvailableFields();
        if (!filterRules.Any())
        {
            AddRule();
        }
    }
    
    private void InitializeAvailableFields()
    {
        // Get properties from TItem type
        var itemType = typeof(TItem);
        availableFields = itemType.GetProperties()
            .Where(p => p.CanRead && IsFilterableType(p.PropertyType))
            .Select(p => new FilterFieldDefinition
            {
                PropertyName = p.Name,
                DisplayName = GetDisplayName(p.Name),
                DataType = GetDataType(p.PropertyType)
            })
            .OrderBy(f => f.DisplayName)
            .ToList();
    }
    
    private bool IsFilterableType(Type type)
    {
        return type == typeof(string) ||
               type == typeof(int) || type == typeof(int?) ||
               type == typeof(decimal) || type == typeof(decimal?) ||
               type == typeof(DateTime) || type == typeof(DateTime?) ||
               type == typeof(bool) || type == typeof(bool?) ||
               type.IsEnum;
    }
    
    private string GetDisplayName(string propertyName)
    {
        // Convert PascalCase to readable format
        return System.Text.RegularExpressions.Regex.Replace(propertyName, "([A-Z])", " $1").Trim();
    }
    
    private string GetDataType(Type type)
    {
        if (type == typeof(string)) return "string";
        if (type == typeof(int) || type == typeof(int?) ||
            type == typeof(decimal) || type == typeof(decimal?)) return "number";
        if (type == typeof(DateTime) || type == typeof(DateTime?)) return "date";
        if (type == typeof(bool) || type == typeof(bool?)) return "boolean";
        if (type.IsEnum) return "enum";
        return "string";
    }
    
    private void ToggleFilterPanel() => isFilterPanelOpen = !isFilterPanelOpen;
    
    private async Task HandleQuickSearch(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await ApplyQuickSearch();
        }
    }
    
    private async Task ApplyQuickSearch()
    {
        if (!string.IsNullOrWhiteSpace(quickSearchTerm))
        {
            // Create filters for searchable string fields
            var searchFilters = availableFields
                .Where(f => f.DataType == "string")
                .Select(f => new FilterRule
                {
                    FieldName = f.PropertyName,
                    Operator = FilterOperator.Contains,
                    Value = quickSearchTerm,
                    LogicalOperator = LogicalOperator.Or
                })
                .ToList();
            
            await OnFiltersChanged.InvokeAsync(searchFilters);
        }
    }
    
    private async Task ClearQuickSearch()
    {
        quickSearchTerm = "";
        await OnFiltersChanged.InvokeAsync(new List<FilterRule>());
    }
    
    private void AddRule()
    {
        filterRules.Add(new FilterRuleViewModel
        {
            LogicalOperator = LogicalOperator.And
        });
    }
    
    private void RemoveRule(FilterRuleViewModel rule)
    {
        filterRules.Remove(rule);
        if (!filterRules.Any())
        {
            AddRule();
        }
    }
    
    private async Task RemoveFilter(FilterRule filter)
    {
        activeFilters.Remove(filter);
        await OnFiltersChanged.InvokeAsync(activeFilters);
    }
    
    private void OnFieldChanged(FilterRuleViewModel rule)
    {
        if (!string.IsNullOrEmpty(rule.FieldName) && Items.Any())
        {
            // Get unique values for the selected field
            var propertyInfo = typeof(TItem).GetProperty(rule.FieldName);
            if (propertyInfo != null)
            {
                rule.AvailableValues = Items
                    .Select(item => propertyInfo.GetValue(item)?.ToString())
                    .Where(value => !string.IsNullOrEmpty(value))
                    .Distinct()
                    .OrderBy(v => v)
                    .Take(100) // Limit to 100 values
                    .ToList();
            }
        }
    }
    
    private void ShowValueDropdown(FilterRuleViewModel rule)
    {
        rule.ShowDropdown = true;
    }
    
    private void HideValueDropdown(FilterRuleViewModel rule)
    {
        // Delay to allow click on dropdown item
        Task.Run(async () =>
        {
            await Task.Delay(200);
            rule.ShowDropdown = false;
            await InvokeAsync(StateHasChanged);
        });
    }
    
    private void SelectValue(FilterRuleViewModel rule, string value)
    {
        rule.Value = value;
        rule.ShowDropdown = false;
    }
    
    private async Task ApplyFilters()
    {
        activeFilters = filterRules
            .Where(r => !string.IsNullOrEmpty(r.FieldName) && r.Value != null && !string.IsNullOrEmpty(r.Value?.ToString()))
            .Select(r => new FilterRule
            {
                FieldName = r.FieldName,
                Operator = r.Operator,
                Value = r.Value,
                LogicalOperator = r.LogicalOperator
            })
            .ToList();
        
        await OnFiltersChanged.InvokeAsync(activeFilters);
        isFilterPanelOpen = false;
    }
    
    private async Task ClearAllFilters()
    {
        activeFilters.Clear();
        filterRules.Clear();
        AddRule();
        quickSearchTerm = "";
        await OnFiltersChanged.InvokeAsync(new List<FilterRule>());
    }
    
    private string GetOperatorDisplay(FilterOperator op)
    {
        return op switch
        {
            FilterOperator.Equals => "=",
            FilterOperator.NotEquals => "≠",
            FilterOperator.Contains => "contains",
            FilterOperator.StartsWith => "starts with",
            FilterOperator.EndsWith => "ends with",
            FilterOperator.GreaterThan => ">",
            FilterOperator.LessThan => "<",
            FilterOperator.Between => "between",
            _ => op.ToString()
        };
    }
}